# Meta Commands

Higher-order frameworks and protocols that coordinate other commands and provide systematic approaches to complex problem-solving.

## Available Commands

### [ulysses-protocol](./ulysses-protocol.md)

High-stakes debugging and problem-solving framework that prevents endless iteration cycles while maintaining quality through systematic phases and decision gates.

### [learning-accelerator](./learning-accelerator.md)

Meta-learning framework that optimizes how the entire command system learns and improves over time.

### [complexity-navigator](./complexity-navigator.md)

Systematic approach to breaking down and managing complexity in large systems and unknown problem domains.

### [feature-discovery](./feature-discovery.md)

Generate diverse, high-quality feature implementations using game theory to escape the "first idea best idea" trap.

### [code-review-game](./code-review-game.md)

Game-theoretic code review protocol that prevents bikeshedding and analysis paralysis while ensuring comprehensive coverage.

### [refactoring-game](./refactoring-game.md)

Execute a game-theoretic refactoring protocol that prevents perfectionism spirals while maintaining code quality.

### [virgil-protocol](./virgil-protocol.md)

A deliberate innovation framework based on Virgil Abloh's 3% Rule: find what already exists, understand why it works, then change only what must be changed.

## Meta-Command Philosophy

### Systematic Over Ad-Hoc

- Defined phases and gates
- Clear decision criteria
- Measurable outcomes
- Learning capture

### Quality Over Quantity

- Time-boxed iterations
- Success criteria validation
- Risk management
- Escalation triggers

### Coordination Over Isolation

- Multiple command integration
- Cross-functional approaches
- Knowledge synthesis
- Process improvement

## When to Use Meta Commands

### High-Stakes Situations

- Production issues affecting users
- Critical architectural decisions
- Complex debugging scenarios
- Time-sensitive implementations

### Complex Problem Domains

- Unknown solution spaces
- Multiple interdependent systems
- Cross-functional requirements
- Long-term strategic decisions

### Process Improvement

- Standardizing team practices
- Improving debugging efficiency
- Accelerating learning cycles
- Building organizational capability

## Integration Patterns

Meta commands orchestrate other command categories:

```bash
# Ulysses Protocol coordinating multiple approaches
/ulysses-protocol "Performance optimization"
  Phase 1: /knowledge-graph + /time-machine
  Phase 2: /implementation-variants + /swarm-intelligence
  Phase 3: /parallel-explorer + /systematic-debug
  Phase 4: /pattern-synthesizer + /context-aware-review
```

## Best Practices

1. **Define Success Criteria Early**: Know what "done" looks like
2. **Time-box All Activities**: Prevent endless cycles
3. **Capture Learning**: Every meta-command execution teaches something
4. **Use Decision Gates**: Stop/continue/escalate based on objective criteria
5. **Coordinate Don't Control**: Let specialized commands do their work

## Meta-Learning Loop

Meta commands improve themselves:

- Track success/failure patterns
- Refine decision criteria
- Optimize time allocations
- Improve coordination strategies
- Build better escalation triggers

This creates compound improvement in problem-solving capability over time.
